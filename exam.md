### Содержание:

[Уровни архитектуры программных систем](#уровни-архитектуры-программных-систем)

[Информационные процессы управления жизненным циклом ПС](#информационные-процессы-управления-жизненным-циклом-пс)

[Архитектурные образцы, эталонные модели и эталонные варианты архитектур](#архитектурные-образцы-эталонные-модели-и-эталонные-варианты-архитектур)

[Архитектурные структуры и представления](#архитектурные-структуры-и-представления)

[Архитектуры, основанные на уровнях абстракции](#архитектуры-основанные-на-уровнях-абстракции)

[Архитектуры, основанные на портах](#архитектуры-основанные-на-портах)

[Архитектуры, основанные на потоках данных](#архитектуры-основанные-на-потоках-данных)

[Архитектуры независимых компонентов. Сервис ориентированные архитектуры](#архитектуры-независимых-компонентов-сервис-ориентированные-архитектуры)

[Архитектурный вид: структура многослойной программной системы](#архитектурный-вид-структура-многослойной-программной-системы)

[Архитектурный вид: размещение программной системы](#архитектурный-вид-размещение-программной-системы)

[Архитектурный вид: размещение программной системы, основанной на потоках данных](#архитектурный-вид-размещение-программной-системы-основанной-на-потоках-данных)

[Архитектурный вид: распределение работ по группам разработчиков](#архитектурный-вид-распределение-работ-по-группам-разработчиков)

[Модули, модульно интерфейсный подход, модульное программирование](#модули-модульно-интерфейсный-подход-модельное-программирование)

[Характеристики модуля: связанность и сцепление](#характеристики-модуля-связанность-и-сцепление)

[Методы оценки сложности. Оценка сложности на основе связанности и сцепления модулей](#методы-оценки-сложности-оценка-сложности-на-основе-связанности-и-сцепления-модулей)

[Модульно интерфейсный подход](#модульно-интерфейсный-подход)

[Объектно ориентированный подход](#объектно-ориентированный-подход)

[Компонентный подход](#компонентный-подход)

[Методы восходящей разработки](#методы-восходящей-разработки)

[Методы нисходящей разработки](#методы-нисходящей-разработки)

[Архитектурный рефакторинг. Рефакторинг кода](#архитектурный-рефакторинг-рефакторинг-кода)

[Рефакторинг архитектуры многослойной иерархической программной системы](#рефакторинг-архитектуры-многослойной-иерархической-программной-системы)

-----------------------------------------------------------------------------------

Архитектура – это:
- набор значимых решений по поводу организации системы программного обеспечения;
- набор структурных элементов и их интерфейсов, при помощи которых компонуется система, вместе с их поведением, определяемым во взаимодействии между этими элементами;
- компоновка элементов в постепенно укрупняющиеся подсистемы, а также стиль архитектуры, который направляет эту организацию – элементы и их интерфейсы, взаимодействия и компоновку.

Общее определение: архитектура это описание подсистем и компонентов программной системы и связей между ними.

## Уровни архитектуры программных систем ([^](#содержание))

Бизнес-архитектура или архитектура организации - относится к бизнес-процессам, принятым в организации, структурам и ролям в организации, а также к общей специализации организации;

Архитектура данных и знаний - включает структуры упорядочивания, хранения и управления информацией (знаиниями) о программной системе и ее компонентах;

Архитектура приложений или архитектура программных средств - совокупность прикладных программ, применяемых для достижения целей конечного пользователя или бизнес-единицы;

Архитектура аппаратных средств - включает железо (серверные компоненты, периферию, связующие компоненты).

## Информационные процессы управления жизненным циклом ПС ([^](#содержание))

Процесс определяется как совокупность взаимосвязанных действий, преобразующих некоторые входные данные в выходные. Каждый процесс характеризуется определенными задачами и методами их решения.

###  Основные:

Процесс приобретения - определение потребностей, анализ требований к ПС, определение поставщика, контроль за деятельностью поставщика;

Процесс поставки - выполняется поставщиком, включает: подготовку договора, планирование работ, выполнение работ, поставку и завершение работ;

Процесс разработки - анализ требований, проектирование архитектуры, разработка, интеграция, тестирование, установка, подготовка эксплуатационной документации, приемка;

Процесс эксплуатации - тестирование, эксплуатация, поддержка пользователей;

Процесс сопровождения - анализ проблем и запросов на эксплуатацию ПС, модификация и модернизация ПС, перенос ПС (при необходимости), вывод ПС из эксплуатации (при необходимости);

### Вспомогательные:

Процесс документирования - добавить нечего;

Процесс управления конфигурацией - мониторинг ПО и железа, принятие решений (о переезде, модернизации, обновлении) на основании текущего состояния ПС;

Процесс обеспечения качества - всякие проверки на соответствие требованиям документации и стандартам (гарантированное соответствие процессов ЖЦ ПС, методов разработки, среды разработки и квалификации персонала условиям договора, установленным стандартам и процедурам);

Процесс верификации - снова проверка на соответствие требованиям документации;

Процесс аттестации - проверка на соответствие результатов тестирования ПС реальности;

Процесс совместной оценки - одна сторона договора проверяет другую на предмет корректности выполнения работ по проекту (управление персоналом, аппаратурой и прочими ресурсами);

Процесс аудита - независимая оценка соответствия требованиям;

Процесс разрешения проблем - добавить нечего;

Все это в совокупности в общем-то и есть процесс обеспечения качества, который может осуществляться как в процессе эксплуатации, так и во время предшествующих ему процессов.

### Организационные:

Процесс управления - инициирование, планирование, оценка затрат, выделение ресурсов, оценка рисков, организация структуры управления;

Процесс создания инфраструктуры - подготовка инфраструктуры для реализации проекта;

Процесс усовершенствования - совершенствование процессов;

Процесс обучения - повышение квалификации персонала по работе с ПС.

## Архитектурные образцы, эталонные модели и эталонные варианты архитектур ([^](#содержание))

### Общие понятия:

Архитектурный образец (стиль) - совокупность ограничений, наладываемых на типы элементов ПС и варианты их взаимодействия. Формирует варианты архитектуры, например клиент-сервер. Подходящий набор образцов применяется к абстракциям, специфичным для конкретной предметной области. Применяются образцы проектирования и каркасы (каркасы предлагают расширяемый шаблон для приложений в определенной предметной области). Ключевой момент - образцы демонстрируют известные атрибуты качества;

Эталонная модель - декомпозиция известной проблемы на части, которые взаимодействуя, способны ее разрешить. Характерна для сформировавшихся предметных областей, т.к. основана на опыте. Можно определить ключевые части действующей системы или отдельного ее модуля (или компилятора, или сборщика) и объяснить как они во взаимодействии решают задачи, поставленные перед системой, и можно будет сказать, что ты знаешь эталонную модель системы.

Эталонная архитектура - эталонная модель, отображенная на программные элементы, которые сообща реализуют функциональность, определенную в эталонной модели, и потоки данных между ними. В то время как эталонная модель обеспечивает разделение функций, эталонная архитектура отображает эти функции на декомпозицию системы.

Варианты архитектур:
- Архитектура, основанная на уровнях абстракций - абстракция представляет собой описание системы или ее части, в котором не указываются абсолютно все детали. Она обеспечивает разработчику общий “макроскопический” обзор системы, в силу чего дает представление о глобальных связях и свойствах основных элементов системы, которое трудно достичь, когда учитываются все подробности. Внимание при данном подходе в первую очередь уделяется правильному распределению функций между уровнями иерархии в системе;
- Архитектура, основанная на портах - основное внимание обращено на методы связи между подсистемами. При использовании механизма портов программная система делится на несколько подсистем, каждая из которых может иметь один или несколько входных портов (одну или несколько входных очередей). Порт – это просто текущий список входных сообщений (список параметров) для подсистемы. Каждая подсистема рассматривается как асинхронный процесс, т.е. все подсистемы работают параллельно. Если одна из них хочет передать некоторые данные другой, она посылает их во входной порт этой другой подсистемы. Если подсистема готова обрабатывать какие-то данные, она читает их из одного из своих входных портов. Для организации такой связи используются операции ПОСЛАТЬ и ПОЛУЧИТЬ;
- Архитектуры, основанные на потоках данных - в общем случае архитектуры, основанные на потоках данных, представляются как совокупность процессов, каждый из которых принимает данные из различных источников, а также возвращает данные в другие источники или хранилища данных. Процессы проектируются независимо друг от друга;
- Архитектуры независимых компонентов - программные системы такой архитектуры состоят из независимо работающих компонентов, время от времени общающихся друг с другом. Компонент, называемый клиентом, выдает запрос для выполнения какого-либо действия к другому компоненту, называемому сервером. Такое отношение называется клиент-серверным;
- Сервис-ориентированные архитектуры (SOA) - В основе SOA лежат принципы многократного использования функциональных элементов информационных технологий, ликвидации дублирования функциональности в программной системе, унификации типовых операционных процессов, обеспечения перевода операционной модели компании на централизованные процессы и функциональную организацию на основе промышленной платформы интеграции. Компоненты программы могут быть распределены по разным узлам сети, и предлагаются как независимые, слабо связанные, заменяемые сервисы-приложения. Программные комплексы, разработанные в соответствии с SOA, часто реализуются как набор веб-сервисов, интегрированных при помощи известных стандартных протоколов (SOAP, WSDL, и т. п.);

## Архитектурные структуры и представления ([^](#содержание))

Представления - отображение ряда связанных архитектурных элементов в том виде, в котором им оперируют заинтересованные в системе лица. В нем фиксируется отображение совокупности элементов и установленных между ними связей;

Структуры - ряд элементов, существующих в раках программного или аппаратного обеспечения. В частности модульная структура представляет собой набор модулей системы с указанием их организации;

Архитектурные структуры подразделяются на 3 общие группы:
- Модульные структуры - состоят из блоков реализации (блоков кода). Отвечают на вопросы: какие требования они (блоки) выполняют, как взаимодействуют между собой, какое ПО используют;
- Структуры “компонент и соединитель” - элементами являются  компоненты (основные единицы вычислений) и соединители (инструменты взаимодействия между компонентами) периода прогона (выполнения). Отвечают на вопросы: каковы основные компоненты и как взаимодействуют, какие хранилища данных используют совместно, как в целом по системе проходят данные, какие изменения происходят в системе во время исполнения;
- Структуры распределения - демонстрируют связь между программными элементами, с одной стороны, и элементами одной или нескольких внешних сред, в которых данное программное обеспечение создается и исполняется – с другой. Они отвечают на вопросы: “На каком процессоре исполняется данный программный элемент? В каких файлах каждый элемент хранится в ходе разработки, тестирования и конструирования системы? Каким образом программные элементы распределяются между группами разработчиков?”

## Архитектуры, основанные на уровнях абстракции ([^](#содержание))

Абстракция представляет собой описание системы или ее части, в котором не указываются абсолютно все детали. Она обеспечивает разработчику общий “макроскопический” обзор системы, в силу чего дает представление о глобальных связях и свойствах основных элементов системы, которое трудно достичь, когда учитываются все подробности. Внимание при данном подходе в первую очередь уделяется правильному распределению функций между уровнями иерархии в системе.
Не существует определенной абстракции для конкретной системы, каждая абстракция дает разработчику различную точку зрения на то, как выглядит система и что она делает. Абстракции системы могут быть тесно связаны.

Свойства уровней абстракций:
- Фундаментальное: на каждом уровне ничего не известно о свойствах более высоких уровней и внутреннем строении других уровней (это уменьшает сложность системы);
- Связь между уровнями осуществляется через жесткие, заранее определенные сопряжения
- Каждый уровень - группа модулей. Имена модулей - сопряжение с более высоким уровнем;
- Каждый уровень владеет определенными ресурсами и либо скрывает их от других уровней, либо предоставляет им некоторые абстракции;
- Каждый уровень может обеспечивать некоторую абстракцию данных;
- Предположения уровней относительно других уровней должны быть минимальны;
- Связи между уровнями ограничены явными аргументами. Недопустимо использование глобальных аргументов;
- Каждая функция должна быть представлена единственным входом;

Условный пример одного из уровней абстракций в системе: модуль, отвечающий за взаимодействие с БД. На верхем уровне имеет АПИ для взаимодействия с БД (базовые CRUD-операции). На уровнях ниже содержит модули отвечающие каждый за create, read, update, delete, например, а также за соединение с БД. Еще один модуль отвечает за получение данных из файловой системы и загрузку их в БД и т.д.

## Архитектуры, основанные на портах ([^](#содержание))

Механизмы, обеспечивающие взаимодействие между частями системы, можно разбить на три группы:
- Предложение GOTO, прерывание, системный вызов, передают управление от одной части программы другой, не передавая явно никаких данных;
- Вызов процедуры или подпрограммы относятся ко второй группе; они передают от одной части системы к другой и управление и данные;
- Механизмы портов - механизмы передачи данных без передачи управления;

Основное внимание обращено на методы связи между подсистемами. При использовании механизма портов программная система делится на несколько подсистем, каждая из которых может иметь один или несколько входных портов (одну или несколько входных очередей). Порт – это просто текущий список входных сообщений (список параметров) для подсистемы. Каждая подсистема рассматривается как асинхронный процесс, т.е. все подсистемы работают параллельно. Если одна из них хочет передать некоторые данные другой, она посылает их во входной порт этой другой подсистемы. Если подсистема готова обрабатывать какие-то данные, она читает их из одного из своих входных портов. Для организации такой связи используются операции ПОСЛАТЬ и ПОЛУЧИТЬ;

Механизм портов увеличивает независимость подсистем, освобождая их от временной зависимости, друг от друга. Более того, подсистемы не должны даже знать о взаимном расположении. Только механизм посылки-получения (почта) должен знать расположение каждой подсистемы.

## Архитектуры, основанные на потоках данных ([^](#содержание))

Современный вариант архитектуры, основанной на портах. Представляются как совокупность процессов, каждый из которых принимает данные из различных источников, а также возвращает данные в другие источники или хранилища данных. Процессы проектируются независимо друг от друга.

## Архитектуры независимых компонентов. Сервис ориентированные архитектуры ([^](#содержание))

### Архитектуры независимых компонентов

Программные системы такой архитектуры состоят из независимо работающих компонентов, время от времени общающихся друг с другом. Компонент, называемый клиентом, выдает запрос для выполнения какого-либо действия к другому компоненту, называемому сервером. Такое отношение называется клиент-серверным;

Существует проблема, связанная с независимыми компонентами: в мире существует громадное количество готовых к использованию информационновычислительных ресурсов, созданных в разное время с разными подходами. Почти всегда при разработке новой информационной системы можно найти подходящие по своим функциям уже работающие готовые компоненты. Проблема состоит в том, что эти компоненты не понимают один другого, они не могут работать совместно.

Решение в объектно-ориентированном подходе и стандарте  COBRA (Common Object Request Broker Architecture). Согласно COBRA, в каждый объект системы добавляется код, обеспечивающий принципиальную возможность взаимодействия объектов. В исходный код программы включаются спецификации интерфейса на языке определения объектных интерфейсов IDL. Для реального взаимодействия объектов предполагается наличие брокера объектных заявок, основная задача которого состоит в доставке заявок на вызов метода вызываемого объекта и возврате результатов выполнения сетода.

### Сервис ориентированные архитектуры (SOA)

В основе SOA лежат принципы многократного использования функциональных элементов информационных технологий, ликвидации дублирования функциональности в программной системе, унификации типовых операционных процессов, обеспечения перевода операционной модели компании на централизованные процессы и функциональную организацию на основе промышленной платформы интеграции. Компоненты программы могут быть распределены по разным узлам сети, и предлагаются как независимые, слабо связанные, заменяемые сервисы-приложения. Программные комплексы, разработанные в соответствии с SOA, часто реализуются как набор веб-сервисов, интегрированных при помощи известных стандартных протоколов (SOAP, WSDL, и т. п.);

Данную архитектуру можно отнести к архитектуре независимых компонентов.

Основным транспортным протоколом является http. Технология не привязана к какой-либо одной платформе, что открывает возможность создания распределенных приложений в гетерогенных средах. Web-сервисы – это технология работы с сообщениями, в которой передача сообщений основана на XML (SOAP), и сами Web-сервисы описываются на XML (WSDL). Логическим продолжением технологии Web-сервисов стала архитектура, ориентированная на сервисы (SOA).

## Архитектурный вид: структура многослойной программной системы ([^](#содержание))

Многослойная архитектура может рассматриваться как результат создания машины пользователя или виртуальной машины, начиная с самого нижнего уровня аппаратуры или ОС.  каждая следующая машина строится на основе предыдущих, расширяя их возможности. Каждый уровень может ссылаться только на один, отличный от него самого уровень, а именно тот, который непосредственно ему предшествует.

## Архитектурный вид: размещение программной системы ([^](#содержание))

Этот архитектурный вид отражает распределение компонентов ПС между элементами аппаратной обработки (компьютеры, аппаратура передачи данных и каналы связи).

Рассматриваются три возможные архитектуры распределения функциональных частей приложения на основе двухуровневой схемы:
- Схема с "тонким клиентом" - клиентский компьютер обладает незначительной вычислительной мощностью и имеет небольшой объем оперативной памяти, а внешней вообще может и не быть. В общем случае под термином «тонкий клиент» подразумевается достаточно широкий с точки зрения системной архитектуры набор устройств и программ, которые объединяются общим свойством - возможностью работы в терминальном режиме. Таким образом, для работы тонкого клиента необходим терминальный сервер;
- Схема с "толстым клиентом" - "толстый клиент" в архитектуре «клиент - сервер» - это приложение, обеспечивающее (в противовес клиенту) расширенную функциональность независимо от центрального сервера. Часто сервер в этом случае является лишь данных (файловым сервером), а вся работа по обработке и представлению этих данных переносится на машину клиента;
- Схема с обычным клиентом - Для расширения функциональности тонкого клиента прибегают к его «утолщению», например добавляют возможности автономной работы, сохраняя главное отличие - работу в сессии с терминальным сервером. Когда в клиенте появляются подвижные детали (жесткие диски), появляются возможности автономной работы, он перестает быть «тонким клиентом» в чистом виде, а становится универсальным клиентом.

## Архитектурный вид: размещение программной системы, основанной на потоках данных ([^](#содержание))

При использовании механизма портов программная система делится на несколько подсистем, каждая из которых может иметь один или несколько входных портов (очередей). Порт - это текущий список входных сообщений для подсистемы. Каждая подсистема рассматривается как асинхронный процесс, т.е. все подсистемы работают параллельно. Если одна из них хочет передать некоторые данные другой, она посылает их во входной порт этой другой подсистемы. Если подсистема готова обрабатывать какие-то данные, она читает их из своих входных портов. Для организации такой связи используются операции ПОСЛАТЬ и ПОЛУЧИТЬ.

В общем случае архитектуры, основанные на потоках данных, представляются как совокупность процессов, каждый из которых принимает данные из различных источников, а также возвращает данные в другие источники или хранилища данных. Процессы проектируются независимо друг от друга.

## Архитектурный вид: распределение работ по группам разработчиков ([^](#содержание))

Задача: выбрать оптимальное распределение специалистов по предстоящим работам с учетом того, что поручить по одной работе каждой группе разработчиков невозможно. Очевидно, оптимальным будет такое распределение, при котором все работы будут выполнены при минимальных затратах рабочего времени. При этом возможно такое решение, что одному исполнителю будет назначено более одной работы.

Ограничения:
- каждый проект в результате решения задачи должен выполняться только одним исполнителем;
- загрузка группы разработчиков не должна превышать ресурс рабочего времени;

Каждое архитектурное представление может иметь множество допустимых вариантов, среди которых есть лучший по некоторому критерию. Задача архитектора заключается в такой формализации возможных вариантов, которая позволит известными методами и достаточно простыми инструментальными средствами выбрать оптимальный вариант в каждом архитектурном представлении программной системы.

## Модули, модульно интерфейсный подход, модульное программирование ([^](#содержание))

Модуль - замкнутая программа, которую можно вызвать из любого другого модуля системы. Состоит из интерфейсной части и части реализации.

Модульность – свойство системы, которая может подвергаться декомпозиции на ряд внутренне связанных и слабо зависящих друг от друга модулей.

Программа разбивается на небольшие (в высокой степени независимые (возможно даже написанные на разных языках)) модули для уменьшения сложности.

Преимущества модульного программирования:
- возможность параллельной разработки;
- появление естественных контрольных точек для наблюдения за продвижением проекта;
- возможность создания библиотек с общеиспользуемыми компонентами или функциональностью;
- обеспечение более полного тестирования (юнит-тестирование);
- упрощается загрузка большой программы в оперативную память;

Недостатки:
- возможное увеличение времени исполнения (и компиляции) программы
- возможно увеличение потребления памяти
- возможные сложности в организации межмодульного взаимодействия

Если собрать воедино требования к модулям получится следующее: модуль должен быть относительно небольшим по объему, иметь один вход и выход, возвращать управление к части программы, которая его вызвала, минимизировать доступ к данным, на которые модуль может ссылаться, не должен сохранять историю своих вызовов и использовать внутренние процедуры.

Идеальный модуль играет роль “черного ящика”, содержимое которого невидимо клиентам. Он прост в использовании – количество “ручек и органов управления” им невелико (аналогия с эксплуатацией телевизора). Его легко развивать и корректировать в процессе сопровождения программной системы. В этом, собственно и заключается суть модульно-интерфейсного подхода: есть модуль, сколько угодно сложно реализованный внутри, но предоставляющий для взаимодействия с ним простой интерфейс.

## Характеристики модуля: связанность и сцепление ([^](#содержание))

Связность (прочность) - мера зависимости частей модуля. Чем выше связность модуля, тем лучше результат проектирования (модуль более закрыт и предоставляет более простой интерфейс).

Существуют следующие типы связанности:
- Связанность по совпадению - отсутствуют явно выраженные логические связи;
- Логическая связанность - по принципу функционального подобия;
- Временная связанность - части не связаны, но необходимы в один период работы программы;
- Процедурная связанность - связь порядком выполняемых действий;
- Коммуникативная связанность - работа с одной и той же структурой данных;
- Функциональная связанность - реализация одной функции;

Сцепление - мера взаимодействия модулей по данным. Характеристика, которую желательно уменьшать. Независимые модули могут быть переделаны без переделки каких-либо других модулей.

Существуют следующие типы сцепления:
- Полностью независимые модули;
- Сцепление по данным - модуль А вызывает модуль Б;
- Сцепление по образцу - модули ссылаются на одну глобальную структуру данных;
- Сцепление по общей области - модули разделяют одну глобальную структуру данных;
- Сцепление по управлению - модуль А явно управляет функционированием модуля Б;
- Сцепление по внешним ссылкам - наличие доступа к данным в другом модуле через внешнюю точку входа;
- Сцепление по кодам (содержанию) - один модуль прямо ссылается на содержание другого модуля (не через его точку входа).

## Методы оценки сложности. Оценка сложности на основе связанности и сцепления модулей ([^](#содержание))

При оценке сложности программ, как правило, выделяют три основные группы метрик:
- метрики размера программ (количество строк исходного текста или метрика Холстеда - количенство операторов и операндов);
- метрики сложности потока управления программ;
- метрики сложности потока данных программ;

Не существует общепринятого мнения, что делает программу простой. Проще та программа, которая использует привычную систему обозначений. Программа с небольшим числом уровней вложенности проще, чем программа, в которой таких уровней много. Существует еще ряд правил достижения простоты программ, вероятно, проще вся программная система, которая тщательно спроектирована.

В простейшем случае сложность системы определяется как сложность ее модулей. Ниже вариант оценки, предложенный Холстедом:

```N ~ n1 * log2 (n1) + n2 * log2 (n2)```

Где N - мера длины модуля, n1 - число различных операторов, n2 - число операндов.

Вторая метрика:

```V = N * log 2 (n1 + n2)```

Где V - объем модуля.

Метрика Т. Джилба определяет сложность как насыщенность выражениями IF_THEN_ELSE и вводит характеристики:
- CL -абсолютная сложность, характеризующаяся количеством операторов условия;
- cl - относительная сложность, вычисляемая как отношение CL к общему числу операторов;
Метрика в последствии была дополнена характеристикой максимального уровня вложенности CLI, которая позволила анализировать циклические конструкции.

Т. МакКейб разработал метрику цикломатической сложности:

```V(G) = E - N + 2```

Где E - количество дуг, N - количество вершин в управляющем графе ПС.

Оценка сложности по методу пограничных значений:

Пусть имеется ``` G = (V,E)``` – ориентированный граф программы c единственной начальной и единственной конечной вершиной. В этом графе число входящих в вершину дуг называется отрицательной степенью вершины, а число исходящих из вершины дуг – положительной степенью вершины. Тогда набор вершин графа можно разбить на две группы:
- вершины, у которых положительная степень <= 1 (принимающие вершины);
- вершины, у которых положительная степень >= 2 (вершины отбора);

Для получения оценки по методу граничных состояний граф разбивается на подграфы (число вершин каждого такого подграфа равно скорректированной сложности вершины отбора).

Скорректированные сложности всех вершин графа суммируются, образуя абсолютную граничную сложность программы. После этого определяется относительная граничная сложность:

```S0 = 1 – (v–1)/Sa```

Где S0 - относимтельная граничная сложность, Sa - абсолютная, v - общее число вершин графа.

Таким образом, при комплексной оценке сложности ПС необходимо рассматривать меру сложности модулей, меру сложности внешних связей (между модулями) и меру сложности внутренних связей (внутри модулей). Традиционно с внешними связями сопоставляют характеристику «сцепление», а с внутренними связями — характеристику «связ-
ность».

Важно также учитывать информационные потоки, нагружающие ребра структуры (т.е. количество информации, проходящей через них). С. Генри и Д. Кафура ввели информационные коэффициенты ifan_in(i) и ifan_out(j). Они учитывают количество элементов и структур данных, из которых i-й модуль берет информацию и которые обновляются j-м модулем соответственно.

### Оценка сложности на основе связанности и сцепления модулей

Одна из возможных моделей сложности модульной программной системы основывается на основных характеристиках ее модулей – связности каждого модуля и сцеплении каждой пары модулей.

Для оценки сложности S программной системы выберем числовой диапазон от 0 до 1. При этом будем считать, что высокая связность и слабое сцепление характеризуется числом, близким к нулю. Таким образом, чем ближе значение S к единице, тем сложнее ПС.

Для полного отображения зависимостей между любой парой модулей вычисляется полная матрица зависимостей. Для этого необходимо:
- Найти все пути в графе между парой модулей;
- Вычислить для каждого найденного пути вероятности как произведения вероятностей соответствующих дуг;
- Вычислить зависимости между модулями, используя вероятности для путей, но, не считая пути взаимно исключающими;

В результате будет получена вероятность того, что необходимо изменить один модуль при изменении другого.

Суммируя все элементы матрицы, и деля сумму на общее число модулей, можно получить оценку сложности программной системы.

## Модульно интерфейсный подход ([^](#содержание))

См. [раздел про модули](#модули-модульно-интерфейсный-подход-модельное-программирование).

Дополнительно:

В общем случае модульная программная система представляет собой древовидную структуру, в узлах которой размещаются программные модули, а направленные дуги показывают статическую подчиненность модулей. Если в тексте модуля имеется ссылка на другой модуль, то их на структурной схеме соединяет дуга, которая исходит из первого модуля и входит во второй модуль. При этом модульная структура программной системы, кроме структурной схемы, должна включать в себя совокупность спецификаций модулей, образующих эту систему.

Подход подразумевает использование структур для разделения различных частей системы (части могут проектироваться отдельно).

Каждый модуль выделяется и описывается, при этом определяется его интерфейс для связи с другими модулями.

Проблема: модули и их интерфейсы могут быть описаны не точно без учета общего операционного окружения, что может привести к нарушению их взаимодействия.

О декомпозиции: на верхних уровнях осуществляется структурная декомпозиция, на средних и нижних – функциональна.

## Объектно ориентированный подход ([^](#содержание))

Выделяют две методики разработки:
- Потребление - активное использование библиотек и классов, разработанных другими командами;
- Производство - разработка собственных (требует более высокой квалификации);

Самой сложной задачей является выявление классов предметной области, сущностей, описывающих задачу предметной области. Каждому такому классу соответствует объект предметной области.

Объект - сущность, которая используется при выполнении некоторой функции или операции.

Обобщенное представление структуры предметной области формируется через уточнение состава классов объектов, определение их атрибутов и взаимосвязей.

В сущности в результате проектирования должно появиться описание сущностей, составляющих предметную область, через классы и их атрибуты. А реализация функциональности будет обеспечена как раз через объекты.

Существуют также и другие типы классов:
- Интерфейсные классы - нужны для связи элементов вне системы с элементами внутри системы;
- Классы-контроллеры - управляют другими классами и обеспечивает передачу данных между классами-сущностями и интерфейсными классами;
- Классы-сущности - могут описывать, например, вид графического интерфейса или сущности из базы данных.

О декомпозиции: декомпозиция связана с правильным подходом к определению классов предметной области. Каждый класс должен согласоваться с принципами хорошего объектно-ориентированного проектирования. К принципам хорошего объектно-ориентированного проектирования, в частности, относятся:
- Принцип единственной ответственности (ПЕО – Single Responsibility Principle (SRP));
- Принцип открытости-закрытости (ПОЗ – OpenClosed Principle (OCP));
- Принцип подстановки Лискова (ППЛ – Liskov Substitution Principle (LSP)).

## Компонентный подход ([^](#содержание))

Компоненты представляют собой автономный код (подсистему), который может быть повторно использован за счет его независимого развертывания.

По сути методы компонентного подхода характерны и для структурного проектирования с модульно-интерфейсным подходом. Если смотреть глубже – это не что иное, как метод декомпозиция сложной системы в первом случае методом сверху вниз, а во втором случае – синтез сложной системы на основе метода проектирования снизу вверх. При этом образуется многоуровневая архитектура программной системы.

При определении архитектуры сверху вниз:
В первую очередь определяются компоненты, а потом их интерфейсы. После определения можно разделить задачи реализации и проектирования компонентов по отдельным группам участников разработки.

При определении структуры снизу вверх:
В первую очередь определяются классы предметной области (которые служат для решения конкретных задач, а не формирования архитектуры приложения).  В результате основные усилия концентрируются, прежде всего, на решении поставленной задачи вместо описания сложной архитектуры. Применяя метод разработки снизу вверх и выявляя классы предметной области, проектировщики имеют больший потенциал для решения поставленной задачи. Кроме того, всегда можно объединить классы предметной области в компоненты, если сложность проекта растет, некоторые группы классов можно развернуть и повторно использовать, включив их в состав компонентов.

## Методы восходящей разработки ([^](#содержание))

При применении данного архитектурного подхода модульная структура системы формируется в процессе программирования модулей, начиная с самого низшего уровня, затем следующего и т. д. При этом модули реализуются в таком порядке, чтобы для каждого программируемого модуля были уже запрограммированы все модули, к которым он может обращаться.

Основные преимущества вытекают из способа структурирования, ограничивающего построение системы. Между разными уровнями можно организовать четкий интерфейс. Каждый уровень может быть проверен в достаточном объеме, а после проверки, можно добавлять части следующего уровня и продолжать проверки (за счет чего можно практически исключить непредвиденные ситуации).

Главная трудность заключается в выборе уровней и иерархическом упорядочении. Кроме того, нельзя показать работу головного модуля (реализуемого в последнюю очередь) заказчику.

Современные подходы не рекомендуют данный метод. Во-первых, для программирования какого-либо модуля можно обойтись без текстов используемых им модулей, достаточно чтобы используемый модуль был специфицирован, а для его тестирования можно заменить используемые модули имитаторами. Во-вторых, каждая программа в какой-то степени подчиняется некоторым внутренним для нее, но глобальной для ее модулей информацией (принципам реализации, предположениям, структурам данных и т. п.), что определяет ее концептуальную целостность. В-третьих, при восходящем тестировании для каждого модуля (кроме головного) приходится создавать ведущую программу, которая должна подготовить для тестируемого модуля необходимое состояние информационной среды и произвести требуемое обращение к нему. Это приводит к большому объему отладочного программирования и не дает гарантии, что тестирование модулей производилось именно в тех условиях, в которых они будут выполняться в рабочей программной системе.

## Методы нисходящей разработки ([^](#содержание))

При применении данного архитектурного подхода (называемого также функциональной декомпозицией) на начальном шаге, используя спецификацию системы, формируеится перечень всех функций системы. Затем определяются подфункции. Далее каждая подфункция может расчленяться до тех пор, пока ее составные части не будут окончательно уточнены. омпоненты системы можно моделировать более детально, по мере того, как продвигается работа по проекту.

Когда система окончательно спроектирована, ее можно реализовать путем замены основных алгоритмов на самом низком уровне абстракции и средств, обеспечиваемых программой моделирования теми элементами, из которых должна быть построена система. Если эта замена сделана правильно, полученная система будет представлять в точности те средства, которые определены на самом высоком уровне.

При реализации программы нисходящим методом первым кодируется головной модуль – модуль верхнего уровня. При этом, поскольку этот вызывает модули соседнего низшего уровня, они представляются заглушками – фиктивными модулями (имитаторами). После того как отлажен головной модуль, заглушки последовательно заменяются функциональными модулями, которые в свою очередь будут вызывающими для следующих заглушек.

## Архитектурный рефакторинг. Рефакторинг кода ([^](#содержание))

Рефакторинг - улучшение качества программного кода без изменения его функциональности. Процесс такого изменения программной системы, при котором не меняется внешнее поведение кода, но улучшается его внутренняя структура.

Преимущества:
- Улучшение композиции программной системы;
- Улучшение понимания структуры программной системы;
- Выявление ошибок;
- Ускорение написания программ;

Если при разработке системы полагаться на рефакторинг (например, используя экстремальное программирование - XP), потребуется контроль наличия следующих условий:
- Наличие автотестов;
- Наличие системы контроля исходного кода;
- Итерационная разработка (вотерфолл не рекомендуется);
- Рефакторинг должен осуществляться регулярно.

### Архитектурный рефакторинг

Потребность в изменении существующей программной системы может возникнуть в ходе решения широкого круга задач по ее модернизации. В общем случае изменения существующей программной системы затрагивают не только программный код, но и все остальные артефакты, связанные с трансформируемой программной системой. Примеры сценариев, требующих изменения архитектуры:
- Преобразования, обусловленные функциональными изменениями ПС;
- Смена платформы ПС;
- Обновление технологии разработки программного продукта, связанное, например, с переходом компонентное программирование или внедрением комплексной среды коллективной разработки;
- Преобразования, связанные с реорганизацией компании, ведущей разработку.

## Рефакторинг архитектуры многослойной иерархической программной системы ([^](#содержание))

Концепция слоев – одна из общеупотребительных моделей, используемых разработчиками программного обеспечения для разделениясложных систем на более простые части. В архитектурах компьютерных систем, например, различают слои кода на языке программирования, функций операционной системы, драйверов устройств, наборов инструкций центрального процессора и внутренней логики микросхем.

Рекомендации:
- Можно выбирать альтернативную реализацию базовых слоев – компоненты верхнего слоя способны работать без каких-либо изменений в нижележащих слоях, при условии сохранения интерфейсов. Зависимость между слоями, то есть, фактически, интерфейсы, предоставляемые нижними слоями верхним, можно свести к минимуму. Такая минимизация интерфейсов позволяет увеличивать гибкость системы;
- Оптимизация слоя транзакций обычно приводит к повышению производительности всех вышележащих слоев;
- Использование паттерна выделения слоев. Выделение слоев – это прием, который позволит сократить и сделать более направленным семантический анализ системы за счет структурного анализа;
- Использование прочих паттернов (каталогизация, автоматизация, верификация, направленность).